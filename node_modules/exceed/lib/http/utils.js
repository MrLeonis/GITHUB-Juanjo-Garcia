'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var callbackPrefix = 'exceed_' + +new Date();

function getCallbackPrefix() {
  return callbackPrefix;
}

function toQueryString(o, trad) {
  var prefix = void 0,
      i = void 0,
      traditional = trad || false,
      s = [],
      enc = encodeURIComponent,
      add = function add(key, value) {
    // If value is a function, invoke it and return its value
    value = typeof value === 'function' ? value() : value == null ? '' : value;
    s[s.length] = enc(key) + '=' + enc(value);
  };
  // If an array was passed in, assume that it is an array of form elements.
  if (Array.isArray(o)) {
    for (i = 0; o && i < o.length; i++) {
      add(o[i].name, o[i].value);
    }
  } else {
    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for (prefix in o) {
      if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add);
    }
  }

  // spaces should be + according to spec
  return s.join('&').replace(/%20/g, '+');
}

function buildParams(prefix, obj, traditional, add) {
  var name = void 0,
      i = void 0,
      v = void 0,
      rbracket = /\[\]$/;

  if (Array.isArray(obj)) {
    // Serialize array item.
    for (i = 0; obj && i < obj.length; i++) {
      v = obj[i];
      if (traditional || rbracket.test(prefix)) {
        // Treat each array item as a scalar.
        add(prefix, v);
      } else {
        buildParams(prefix + '[' + ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' ? i : '') + ']', v, traditional, add);
      }
    }
  } else if (obj && obj.toString() === '[object Object]') {
    // Serialize object item.
    for (name in obj) {
      buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
    }
  } else {
    // Serialize scalar item.
    add(prefix, obj);
  }
}

// normalize newline variants according to spec -> CRLF
function normalize(s) {
  return s ? s.replace(/\r?\n/g, '\r\n') : '';
}

function serial(el, cb) {
  var n = el.name,
      t = el.tagName.toLowerCase(),
      optCb = function optCb(o) {
    // IE gives value="" even where there is no value attribute
    // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
    if (o && !o.disabled) {
      cb(n, normalize(o.attributes.value && o.attributes.value.specified ? o.value : o.text));
    }
  },
      ch = void 0,
      ra = void 0,
      val = void 0,
      i = void 0;

  // don't serialize elements that are disabled or without a name
  if (el.disabled || !n) return;

  switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type);
        ra = /radio/i.test(el.type);
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val));
      }
      break;
    case 'textarea':
      cb(n, normalize(el.value));
      break;
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i]);
        }
      }
      break;
  }
}

module.exports = {
  getCallbackPrefix: getCallbackPrefix,
  toQueryString: toQueryString,
  buildParams: buildParams,
  normalize: normalize,
  serial: serial
};