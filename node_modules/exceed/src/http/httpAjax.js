'use strict';

const { getCallbackPrefix, toQueryString, buildParams } = require('./utils');

let context;

// This works in non-strict mode
context = (function () {
  return this;
}());

try {
  // This works if eval is allowed (see CSP)
  context = context || Function('return this')() || (1, eval)('this');
} catch (e) {
  // This works if the window reference is available
  if (typeof window === 'object') { context = window; }
}


if ('document' in context) {
  var doc = document,
    byTag = 'getElementsByTagName',
    head = doc[byTag]('head')[0];
} else {
  var XHR2 = require('xhr2');
}

let httpsRe = /^http/,
  protocolRe = /(^\w+):\/\//,
  twoHundo = /^(20\d|1223)$/, // http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  readyState = 'readyState',
  contentType = 'Content-Type',
  requestedWith = 'X-Requested-With',
  uniqid = 0,
  lastValue, // data stored by the most recent JSONP callback
  xmlHttpRequest = 'XMLHttpRequest',
  xDomainRequest = 'XDomainRequest',
  noop = function () { },
  defaultHeaders = {
    contentType: 'application/x-www-form-urlencoded',
    requestedWith: xmlHttpRequest,
    accept: {
      '*': 'text/javascript, text/html, application/xml, text/xml, */*',
      xml: 'application/xml, text/xml',
      html: 'text/html',
      text: 'text/plain',
      json: 'application/json, text/javascript',
      js: 'application/javascript, text/javascript',
    },
  },

  xhr = function (o) {
    // is it x-domain
    if (o.crossOrigin === true) {
      const xhr = context[xmlHttpRequest] ? new XMLHttpRequest() : null;
      if (xhr && 'withCredentials' in xhr) {
        return xhr;
      } else if (context[xDomainRequest]) {
        const protocolRegExp = /^https?/;
        if (window.location.href.match(protocolRegExp)[0] !== o.url.match(protocolRegExp)[0]) {
          throw new Error('XDomainRequest: requests must be targeted to the same scheme as the hosting page.');
          // As per: http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
        }
        return new XDomainRequest();
      }
      throw new Error('Browser does not support cross-origin requests');
    } else if (context[xmlHttpRequest]) {
      return new XMLHttpRequest();
    } else if (XHR2) {
      return new XHR2();
    } else {
      return new ActiveXObject('Microsoft.XMLHTTP');
    }
  },
  globalSetupOptions = {
    dataFilter(data) {
      return data;
    },
  };

function succeed(r) {
  let protocol = protocolRe.exec(r.url);
  protocol = (protocol && protocol[1]) || context.location.protocol;
  return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
}

function handleReadyState(r, success, error) {
  return function () {
    // use _aborted to mitigate against IE err c00c023f
    // (can't read props on aborted request objects)
    if (r._aborted) return error(r.request);
    if (r._timedOut) return error(r.request, 'Request is aborted: timeout');
    if (r.request && r.request[readyState] == 4) {
      r.request.onreadystatechange = noop;
      if (succeed(r)) success(r.request);
      else { error(r.request); }
    }
  };
}

function getRequest(fn, err) {
  let o = this.o,
    method = (o.method || 'GET').toUpperCase(),
    url = typeof o === 'string' ? o : o.url,
    // convert non-string objects to query-string form unless o['processData'] is false
    data = (o.processData !== false && o.data && typeof o.data !== 'string')
      ? toQueryString(o.data)
      : (o.data || null),
    http,
    sendWait = false;

  // if we're working on a GET request and we have data then we should append
  // query string to end of URL and not post data
  if ((o.type == 'jsonp' || method == 'GET') && data) {
    url = urlappend(url, data);
    data = null;
  }

  if (o.type == 'jsonp') return handleJsonp(o, fn, err, url);

  // get the xhr from the factory if passed
  // if the factory returns null, fall-back to ours
  http = (o.xhr && o.xhr(o)) || xhr(o);

  http.open(method, url, o.async !== false);
  setHeaders(http, o);
  setCredentials(http, o);
  if (context[xDomainRequest] && http instanceof context[xDomainRequest]) {
    http.onload = fn;
    http.onerror = err;
    // NOTE: see
    // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
    http.onprogress = function () { };
    sendWait = true;
  } else {
    http.onreadystatechange = handleReadyState(this, fn, err);
  }
  o.before && o.before(http);
  if (sendWait) {
    setTimeout(() => {
      http.send(data);
    }, 200);
  } else {
    http.send(data);
  }
  return http;
}

function handleJsonp(o, fn, err, url) {
  let reqId = uniqid++,
    cbkey = o.jsonpCallback || 'callback', // the 'callback' key
    cbval = o.jsonpCallbackName || getCallbackPrefix(reqId),
    cbreg = new RegExp(`((^|\\?|&)${cbkey})=([^&]+)`),
    match = url.match(cbreg),
    script = doc.createElement('script'),
    loaded = 0,
    isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1;

  if (match) {
    if (match[3] === '?') {
      url = url.replace(cbreg, `$1=${cbval}`); // wildcard callback func name
    } else {
      cbval = match[3]; // provided callback func name
    }
  } else {
    url = urlappend(url, `${cbkey}=${cbval}`); // no callback details, add 'em
  }

  context[cbval] = generalCallback;

  script.type = 'text/javascript';
  script.src = url;
  script.async = true;
  if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
    // need this for IE due to out-of-order onreadystatechange(), binding script
    // execution to an event listener gives us control over when the script
    // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    script.htmlFor = script.id = `_exceed_${reqId}`;
  }

  script.onload = script.onreadystatechange = function () {
    if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
      return false;
    }
    script.onload = script.onreadystatechange = null;
    script.onclick && script.onclick();
    // Call the user callback with the last value stored and clean up values and scripts.
    fn(lastValue);
    lastValue = undefined;
    head.removeChild(script);
    loaded = 1;
  };

  // Add the script to the DOM head
  head.appendChild(script);

  // Enable JSONP timeout
  return {
    abort() {
      script.onload = script.onreadystatechange = null;
      err({}, 'Request is aborted: timeout', {});
      lastValue = undefined;
      head.removeChild(script);
      loaded = 1;
    },
  };
}

function setHeaders(http, o) {
  let headers = o.headers || {},
    h;

  headers.Accept = headers.Accept
    || defaultHeaders.accept[o.type]
    || defaultHeaders.accept['*'];

  const isAFormData = typeof FormData !== 'undefined' && (o.data instanceof FormData);
  // breaks cross-origin requests with legacy browsers
  if (!o.crossOrigin && !headers[requestedWith]) headers[requestedWith] = defaultHeaders.requestedWith;
  if (!headers[contentType] && !isAFormData) headers[contentType] = o.contentType || defaultHeaders.contentType;
  for (h in headers) { headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h]); }
}

function setCredentials(http, o) {
  if (typeof o.withCredentials !== 'undefined' && typeof http.withCredentials !== 'undefined') {
    http.withCredentials = !!o.withCredentials;
  }
}

function generalCallback(data) {
  lastValue = data;
}

function urlappend(url, s) {
  return url + (/\?/.test(url) ? '&' : '?') + s;
}

function HttpAjax(o, fn) {
  this.o = o;
  this.fn = fn;

  init.apply(this, arguments);
}

function setType(header) {
  // json, javascript, text/plain, text/html, xml
  if (header === null) return undefined; // In case of no content-type.
  if (header.match('json')) return 'json';
  if (header.match('javascript')) return 'js';
  if (header.match('text')) return 'html';
  if (header.match('xml')) return 'xml';
}

function init(o, fn) {
  this.url = typeof o === 'string' ? o : o.url;
  this.timeout = null;

  // whether request has been fulfilled for purpose
  // of tracking the Promises
  this._fulfilled = false;
  // success handlers
  this._successHandlers = [];
  this._fulfillmentHandlers = [];
  // error handlers
  this._errorHandlers = [];
  // complete (both success and fail) handlers
  this._completeHandlers = [];
  this._erred = false;
  this._responseArgs = {};

  const self = this;

  fn = fn || function () { };

  if (o.timeout) {
    this.timeout = setTimeout(() => {
      timedOut();
    }, o.timeout);
  }

  if (o.success) {
    while (o.success.length > 0) {
      const successHandler = o.success.shift();
      this._successHandlers.push((resp, originResp) => {
        successHandler(resp, o, originResp);
      });
    }
  }

  if (o.error) {
    while (o.error.length > 0) {
      const errorHandler = o.error.shift();
      this._errorHandlers.push((resp, msg, t) => {
        errorHandler(resp, msg, t, o);
      });
    }
  }

  if (o.complete) {
    while (o.complete.length > 0) {
      const completeHandler = o.complete.shift();
      this._completeHandlers.push(() => {
        completeHandler(arguments, o);
      });
    }
  }

  function complete(resp) {
    o.timeout && clearTimeout(self.timeout);
    self.timeout = null;
    while (self._completeHandlers.length > 0) {
      const completeHandler = self._completeHandlers.shift();
      completeHandler(resp);
    }
  }

  function success(resp) {
    const originResp = resp;
    const type = o.type || resp && setType(resp.getResponseHeader('Content-Type')); // resp can be undefined in IE
    resp = (type !== 'jsonp') ? self.request : resp;
    // use global data filter on response text
    let filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type),
      r = filteredResponse;
    try {
      resp.responseText = r;
    } catch (e) {
      // can't assign this in IE<=8, just ignore
    }
    if (r) {
      switch (type) {
        case 'json':
          try {
            resp = context.JSON ? context.JSON.parse(r) : eval(`(${r})`);
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err);
          }
          break;
        case 'js':
          resp = eval(r);
          break;
        case 'html':
          resp = r;
          break;
        case 'xml':
          resp = resp.responseXML
            && resp.responseXML.parseError // IE trololo
            && resp.responseXML.parseError.errorCode
            && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML;
          break;
      }
    } else if (type !== 'jsonp') {
      // 兜底，加入r为空，则直接返回空
      resp = r;
    }

    self._responseArgs.resp = resp;
    self._fulfilled = true;
    fn(resp);
    while (self._successHandlers.length > 0) {
      const successHandler = self._successHandlers.shift();
      successHandler(resp, originResp);
    }
    while (self._fulfillmentHandlers.length > 0) {
      const fulfillmentHandler = self._fulfillmentHandlers.shift();
      fulfillmentHandler(resp);
    }

    complete(resp);
  }

  function timedOut() {
    self._timedOut = true;
    self.request.abort();
  }

  function error(resp, msg, t) {
    resp = self.request;
    self._responseArgs.resp = resp;
    self._responseArgs.msg = msg;
    self._responseArgs.t = t;
    self._erred = true;
    while (self._errorHandlers.length > 0) {
      const errorHandler = self._errorHandlers.shift();
      errorHandler(resp, msg, t);
    }
    complete(resp);
  }

  this.request = getRequest.call(this, success, error);
}

HttpAjax.prototype = {
  abort() {
    this._aborted = true;
    this.request.abort();
  },

  retry() {
    init.call(this, this.o, this.fn);
  },

  /**
   * Small deviation from the Promises A CommonJs specification
   * http://wiki.commonjs.org/wiki/Promises/A
   */

  /**
   * `then` will execute upon successful requests
   */
  then(success, fail) {
    success = success || function () { };
    fail = fail || function () { };
    if (this._fulfilled) {
      this._responseArgs.resp = success(this._responseArgs.resp);
    } else if (this._erred) {
      fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
    } else {
      // 目前仅执行此步
      this._fulfillmentHandlers.push(success);
      this._errorHandlers.push(fail);
    }
    return this;
  },

  /**
   * `always` will execute whether the request succeeds or fails
   */
  always(fn) {
    if (this._fulfilled || this._erred) {
      fn(this._responseArgs.resp);
    } else {
      this._completeHandlers.push(fn);
    }
    return this;
  },

  /**
   * `fail` will execute when the request fails
   */
  fail(fn) {
    fn = fn || function () { };
    if (this._erred) {
      fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
    } else {
      this._errorHandlers.push(fn);
    }
    return this;
  },

  catch(fn) {
    return this.fail(fn);
  },
};

module.exports = HttpAjax;
